// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: client.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "client.pb.h"

#include <algorithm>

#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/wire_format.h>
#include <google/protobuf/wire_format_lite_inl.h>
// @@protoc_insertion_point(includes)

namespace challenge {

namespace {

const ::google::protobuf::Descriptor *ServerInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection
    *ServerInfo_reflection_ = NULL;

} // namespace

void protobuf_AssignDesc_client_2eproto() GOOGLE_ATTRIBUTE_COLD;
void protobuf_AssignDesc_client_2eproto() {
  protobuf_AddDesc_client_2eproto();
  const ::google::protobuf::FileDescriptor *file =
      ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
          "client.proto");
  GOOGLE_CHECK(file != NULL);
  ServerInfo_descriptor_ = file->message_type(0);
  static const int ServerInfo_offsets_[5] = {
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ServerInfo, address_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ServerInfo, port_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ServerInfo, package_size_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ServerInfo, file_name_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ServerInfo, timeout_ms_),
  };
  ServerInfo_reflection_ = ::google::protobuf::internal::
      GeneratedMessageReflection::NewGeneratedMessageReflection(
          ServerInfo_descriptor_, ServerInfo::default_instance_,
          ServerInfo_offsets_,
          GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ServerInfo,
                                                         _has_bits_[0]),
          -1, -1, sizeof(ServerInfo),
          GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ServerInfo,
                                                         _internal_metadata_),
          -1);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                                     &protobuf_AssignDesc_client_2eproto);
}

void protobuf_RegisterTypes(const ::std::string &) GOOGLE_ATTRIBUTE_COLD;
void protobuf_RegisterTypes(const ::std::string &) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      ServerInfo_descriptor_, &ServerInfo::default_instance());
}

} // namespace

void protobuf_ShutdownFile_client_2eproto() {
  delete ServerInfo::default_instance_;
  delete ServerInfo_reflection_;
}

void protobuf_AddDesc_client_2eproto() GOOGLE_ATTRIBUTE_COLD;
void protobuf_AddDesc_client_2eproto() {
  static bool already_here = false;
  if (already_here)
    return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
      "\n\014client.proto\022\tchallenge\"h\n\nServerInfo\022"
      "\017\n\007address\030\001 \001(\t\022\014\n\004port\030\002 "
      "\002(\005\022\024\n\014packag"
      "e_size\030\003 \002(\005\022\021\n\tfile_name\030\004 "
      "\002(\t\022\022\n\ntimeo"
      "ut_ms\030\005 \002(\005",
      131);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
      "client.proto", &protobuf_RegisterTypes);
  ServerInfo::default_instance_ = new ServerInfo();
  ServerInfo::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(
      &protobuf_ShutdownFile_client_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_client_2eproto {
  StaticDescriptorInitializer_client_2eproto() {
    protobuf_AddDesc_client_2eproto();
  }
} static_descriptor_initializer_client_2eproto_;

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ServerInfo::kAddressFieldNumber;
const int ServerInfo::kPortFieldNumber;
const int ServerInfo::kPackageSizeFieldNumber;
const int ServerInfo::kFileNameFieldNumber;
const int ServerInfo::kTimeoutMsFieldNumber;
#endif // !defined(_MSC_VER) || _MSC_VER >= 1900

ServerInfo::ServerInfo()
    : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:challenge.ServerInfo)
}

void ServerInfo::InitAsDefaultInstance() {}

ServerInfo::ServerInfo(const ServerInfo &from)
    : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:challenge.ServerInfo)
}

void ServerInfo::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  address_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  port_ = 0;
  package_size_ = 0;
  file_name_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  timeout_ms_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ServerInfo::~ServerInfo() {
  // @@protoc_insertion_point(destructor:challenge.ServerInfo)
  SharedDtor();
}

void ServerInfo::SharedDtor() {
  address_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  file_name_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void ServerInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor *ServerInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ServerInfo_descriptor_;
}

const ServerInfo &ServerInfo::default_instance() {
  if (default_instance_ == NULL)
    protobuf_AddDesc_client_2eproto();
  return *default_instance_;
}

ServerInfo *ServerInfo::default_instance_ = NULL;

ServerInfo *ServerInfo::New(::google::protobuf::Arena *arena) const {
  ServerInfo *n = new ServerInfo;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ServerInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:challenge.ServerInfo)
#if defined(__clang__)
#define ZR_HELPER_(f)                                                          \
  _Pragma("clang diagnostic push")                                             \
      _Pragma("clang diagnostic ignored "                                      \
              "\"-Winvalid-offsetof\"") __builtin_offsetof(ServerInfo, f)      \
          _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f)                                                          \
  reinterpret_cast<char *>(&reinterpret_cast<ServerInfo *>(16)->f)
#endif

#define ZR_(first, last)                                                       \
  do {                                                                         \
    ::memset(&first, 0, ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));  \
  } while (0)

  if (_has_bits_[0 / 32] & 31u) {
    ZR_(port_, package_size_);
    if (has_address()) {
      address_.ClearToEmptyNoArena(
          &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_file_name()) {
      file_name_.ClearToEmptyNoArena(
          &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    timeout_ms_ = 0;
  }

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool ServerInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream *input) {
#define DO_(EXPRESSION)                                                        \
  if (!GOOGLE_PREDICT_TRUE(EXPRESSION))                                        \
  goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:challenge.ServerInfo)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p =
        input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second)
      goto handle_unusual;
    switch (
        ::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
    // optional string address = 1;
    case 1: {
      if (tag == 10) {
        DO_(::google::protobuf::internal::WireFormatLite::ReadString(
            input, this->mutable_address()));
        ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->address().data(), this->address().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "challenge.ServerInfo.address");
      } else {
        goto handle_unusual;
      }
      if (input->ExpectTag(16))
        goto parse_port;
      break;
    }

    // required int32 port = 2;
    case 2: {
      if (tag == 16) {
      parse_port:
        DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
             ::google::protobuf::int32,
             ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
            input, &port_)));
        set_has_port();
      } else {
        goto handle_unusual;
      }
      if (input->ExpectTag(24))
        goto parse_package_size;
      break;
    }

    // required int32 package_size = 3;
    case 3: {
      if (tag == 24) {
      parse_package_size:
        DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
             ::google::protobuf::int32,
             ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
            input, &package_size_)));
        set_has_package_size();
      } else {
        goto handle_unusual;
      }
      if (input->ExpectTag(34))
        goto parse_file_name;
      break;
    }

    // required string file_name = 4;
    case 4: {
      if (tag == 34) {
      parse_file_name:
        DO_(::google::protobuf::internal::WireFormatLite::ReadString(
            input, this->mutable_file_name()));
        ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->file_name().data(), this->file_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "challenge.ServerInfo.file_name");
      } else {
        goto handle_unusual;
      }
      if (input->ExpectTag(40))
        goto parse_timeout_ms;
      break;
    }

    // required int32 timeout_ms = 5;
    case 5: {
      if (tag == 40) {
      parse_timeout_ms:
        DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
             ::google::protobuf::int32,
             ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
            input, &timeout_ms_)));
        set_has_timeout_ms();
      } else {
        goto handle_unusual;
      }
      if (input->ExpectAtEnd())
        goto success;
      break;
    }

    default: {
    handle_unusual:
      if (tag == 0 ||
          ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
              ::google::protobuf::internal::WireFormatLite::
                  WIRETYPE_END_GROUP) {
        goto success;
      }
      DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, mutable_unknown_fields()));
      break;
    }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:challenge.ServerInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:challenge.ServerInfo)
  return false;
#undef DO_
}

void ServerInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream *output) const {
  // @@protoc_insertion_point(serialize_start:challenge.ServerInfo)
  // optional string address = 1;
  if (has_address()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
        this->address().data(), this->address().length(),
        ::google::protobuf::internal::WireFormat::SERIALIZE,
        "challenge.ServerInfo.address");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
        1, this->address(), output);
  }

  // required int32 port = 2;
  if (has_port()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->port(),
                                                             output);
  }

  // required int32 package_size = 3;
  if (has_package_size()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(
        3, this->package_size(), output);
  }

  // required string file_name = 4;
  if (has_file_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
        this->file_name().data(), this->file_name().length(),
        ::google::protobuf::internal::WireFormat::SERIALIZE,
        "challenge.ServerInfo.file_name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
        4, this->file_name(), output);
  }

  // required int32 timeout_ms = 5;
  if (has_timeout_ms()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(
        5, this->timeout_ms(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:challenge.ServerInfo)
}

::google::protobuf::uint8 *ServerInfo::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8 *target) const {
  // @@protoc_insertion_point(serialize_to_array_start:challenge.ServerInfo)
  // optional string address = 1;
  if (has_address()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
        this->address().data(), this->address().length(),
        ::google::protobuf::internal::WireFormat::SERIALIZE,
        "challenge.ServerInfo.address");
    target = ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->address(), target);
  }

  // required int32 port = 2;
  if (has_port()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(
        2, this->port(), target);
  }

  // required int32 package_size = 3;
  if (has_package_size()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(
        3, this->package_size(), target);
  }

  // required string file_name = 4;
  if (has_file_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
        this->file_name().data(), this->file_name().length(),
        ::google::protobuf::internal::WireFormat::SERIALIZE,
        "challenge.ServerInfo.file_name");
    target = ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->file_name(), target);
  }

  // required int32 timeout_ms = 5;
  if (has_timeout_ms()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(
        5, this->timeout_ms(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target =
        ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
            unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:challenge.ServerInfo)
  return target;
}

int ServerInfo::RequiredFieldsByteSizeFallback() const {
  // @@protoc_insertion_point(required_fields_byte_size_fallback_start:challenge.ServerInfo)
  int total_size = 0;

  if (has_port()) {
    // required int32 port = 2;
    total_size += 1 + ::google::protobuf::internal::WireFormatLite::Int32Size(
                          this->port());
  }

  if (has_package_size()) {
    // required int32 package_size = 3;
    total_size += 1 + ::google::protobuf::internal::WireFormatLite::Int32Size(
                          this->package_size());
  }

  if (has_file_name()) {
    // required string file_name = 4;
    total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                          this->file_name());
  }

  if (has_timeout_ms()) {
    // required int32 timeout_ms = 5;
    total_size += 1 + ::google::protobuf::internal::WireFormatLite::Int32Size(
                          this->timeout_ms());
  }

  return total_size;
}
int ServerInfo::ByteSize() const {
  // @@protoc_insertion_point(message_byte_size_start:challenge.ServerInfo)
  int total_size = 0;

  if (((_has_bits_[0] & 0x0000001e) ^ 0x0000001e) ==
      0) { // All required fields are present.
    // required int32 port = 2;
    total_size += 1 + ::google::protobuf::internal::WireFormatLite::Int32Size(
                          this->port());

    // required int32 package_size = 3;
    total_size += 1 + ::google::protobuf::internal::WireFormatLite::Int32Size(
                          this->package_size());

    // required string file_name = 4;
    total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                          this->file_name());

    // required int32 timeout_ms = 5;
    total_size += 1 + ::google::protobuf::internal::WireFormatLite::Int32Size(
                          this->timeout_ms());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  // optional string address = 1;
  if (has_address()) {
    total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                          this->address());
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
        ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
            unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ServerInfo::MergeFrom(const ::google::protobuf::Message &from) {
  // @@protoc_insertion_point(generalized_merge_from_start:challenge.ServerInfo)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const ServerInfo *source =
      ::google::protobuf::internal::DynamicCastToGenerated<const ServerInfo>(
          &from);
  if (source == NULL) {
    // @@protoc_insertion_point(generalized_merge_from_cast_fail:challenge.ServerInfo)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    // @@protoc_insertion_point(generalized_merge_from_cast_success:challenge.ServerInfo)
    MergeFrom(*source);
  }
}

void ServerInfo::MergeFrom(const ServerInfo &from) {
  // @@protoc_insertion_point(class_specific_merge_from_start:challenge.ServerInfo)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_address()) {
      set_has_address();
      address_.AssignWithDefault(
          &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
          from.address_);
    }
    if (from.has_port()) {
      set_port(from.port());
    }
    if (from.has_package_size()) {
      set_package_size(from.package_size());
    }
    if (from.has_file_name()) {
      set_has_file_name();
      file_name_.AssignWithDefault(
          &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
          from.file_name_);
    }
    if (from.has_timeout_ms()) {
      set_timeout_ms(from.timeout_ms());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void ServerInfo::CopyFrom(const ::google::protobuf::Message &from) {
  // @@protoc_insertion_point(generalized_copy_from_start:challenge.ServerInfo)
  if (&from == this)
    return;
  Clear();
  MergeFrom(from);
}

void ServerInfo::CopyFrom(const ServerInfo &from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:challenge.ServerInfo)
  if (&from == this)
    return;
  Clear();
  MergeFrom(from);
}

bool ServerInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001e) != 0x0000001e)
    return false;

  return true;
}

void ServerInfo::Swap(ServerInfo *other) {
  if (other == this)
    return;
  InternalSwap(other);
}
void ServerInfo::InternalSwap(ServerInfo *other) {
  address_.Swap(&other->address_);
  std::swap(port_, other->port_);
  std::swap(package_size_, other->package_size_);
  file_name_.Swap(&other->file_name_);
  std::swap(timeout_ms_, other->timeout_ms_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ServerInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ServerInfo_descriptor_;
  metadata.reflection = ServerInfo_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ServerInfo

// optional string address = 1;
bool ServerInfo::has_address() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ServerInfo::set_has_address() { _has_bits_[0] |= 0x00000001u; }
void ServerInfo::clear_has_address() { _has_bits_[0] &= ~0x00000001u; }
void ServerInfo::clear_address() {
  address_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_address();
}
const ::std::string &ServerInfo::address() const {
  // @@protoc_insertion_point(field_get:challenge.ServerInfo.address)
  return address_.GetNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void ServerInfo::set_address(const ::std::string &value) {
  set_has_address();
  address_.SetNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:challenge.ServerInfo.address)
}
void ServerInfo::set_address(const char *value) {
  set_has_address();
  address_.SetNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:challenge.ServerInfo.address)
}
void ServerInfo::set_address(const char *value, size_t size) {
  set_has_address();
  address_.SetNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char *>(value), size));
  // @@protoc_insertion_point(field_set_pointer:challenge.ServerInfo.address)
}
::std::string *ServerInfo::mutable_address() {
  set_has_address();
  // @@protoc_insertion_point(field_mutable:challenge.ServerInfo.address)
  return address_.MutableNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string *ServerInfo::release_address() {
  // @@protoc_insertion_point(field_release:challenge.ServerInfo.address)
  clear_has_address();
  return address_.ReleaseNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void ServerInfo::set_allocated_address(::std::string *address) {
  if (address != NULL) {
    set_has_address();
  } else {
    clear_has_address();
  }
  address_.SetAllocatedNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited(), address);
  // @@protoc_insertion_point(field_set_allocated:challenge.ServerInfo.address)
}

// required int32 port = 2;
bool ServerInfo::has_port() const { return (_has_bits_[0] & 0x00000002u) != 0; }
void ServerInfo::set_has_port() { _has_bits_[0] |= 0x00000002u; }
void ServerInfo::clear_has_port() { _has_bits_[0] &= ~0x00000002u; }
void ServerInfo::clear_port() {
  port_ = 0;
  clear_has_port();
}
::google::protobuf::int32 ServerInfo::port() const {
  // @@protoc_insertion_point(field_get:challenge.ServerInfo.port)
  return port_;
}
void ServerInfo::set_port(::google::protobuf::int32 value) {
  set_has_port();
  port_ = value;
  // @@protoc_insertion_point(field_set:challenge.ServerInfo.port)
}

// required int32 package_size = 3;
bool ServerInfo::has_package_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void ServerInfo::set_has_package_size() { _has_bits_[0] |= 0x00000004u; }
void ServerInfo::clear_has_package_size() { _has_bits_[0] &= ~0x00000004u; }
void ServerInfo::clear_package_size() {
  package_size_ = 0;
  clear_has_package_size();
}
::google::protobuf::int32 ServerInfo::package_size() const {
  // @@protoc_insertion_point(field_get:challenge.ServerInfo.package_size)
  return package_size_;
}
void ServerInfo::set_package_size(::google::protobuf::int32 value) {
  set_has_package_size();
  package_size_ = value;
  // @@protoc_insertion_point(field_set:challenge.ServerInfo.package_size)
}

// required string file_name = 4;
bool ServerInfo::has_file_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void ServerInfo::set_has_file_name() { _has_bits_[0] |= 0x00000008u; }
void ServerInfo::clear_has_file_name() { _has_bits_[0] &= ~0x00000008u; }
void ServerInfo::clear_file_name() {
  file_name_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_file_name();
}
const ::std::string &ServerInfo::file_name() const {
  // @@protoc_insertion_point(field_get:challenge.ServerInfo.file_name)
  return file_name_.GetNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void ServerInfo::set_file_name(const ::std::string &value) {
  set_has_file_name();
  file_name_.SetNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:challenge.ServerInfo.file_name)
}
void ServerInfo::set_file_name(const char *value) {
  set_has_file_name();
  file_name_.SetNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:challenge.ServerInfo.file_name)
}
void ServerInfo::set_file_name(const char *value, size_t size) {
  set_has_file_name();
  file_name_.SetNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char *>(value), size));
  // @@protoc_insertion_point(field_set_pointer:challenge.ServerInfo.file_name)
}
::std::string *ServerInfo::mutable_file_name() {
  set_has_file_name();
  // @@protoc_insertion_point(field_mutable:challenge.ServerInfo.file_name)
  return file_name_.MutableNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string *ServerInfo::release_file_name() {
  // @@protoc_insertion_point(field_release:challenge.ServerInfo.file_name)
  clear_has_file_name();
  return file_name_.ReleaseNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void ServerInfo::set_allocated_file_name(::std::string *file_name) {
  if (file_name != NULL) {
    set_has_file_name();
  } else {
    clear_has_file_name();
  }
  file_name_.SetAllocatedNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited(), file_name);
  // @@protoc_insertion_point(field_set_allocated:challenge.ServerInfo.file_name)
}

// required int32 timeout_ms = 5;
bool ServerInfo::has_timeout_ms() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void ServerInfo::set_has_timeout_ms() { _has_bits_[0] |= 0x00000010u; }
void ServerInfo::clear_has_timeout_ms() { _has_bits_[0] &= ~0x00000010u; }
void ServerInfo::clear_timeout_ms() {
  timeout_ms_ = 0;
  clear_has_timeout_ms();
}
::google::protobuf::int32 ServerInfo::timeout_ms() const {
  // @@protoc_insertion_point(field_get:challenge.ServerInfo.timeout_ms)
  return timeout_ms_;
}
void ServerInfo::set_timeout_ms(::google::protobuf::int32 value) {
  set_has_timeout_ms();
  timeout_ms_ = value;
  // @@protoc_insertion_point(field_set:challenge.ServerInfo.timeout_ms)
}

#endif // PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

} // namespace challenge

// @@protoc_insertion_point(global_scope)
